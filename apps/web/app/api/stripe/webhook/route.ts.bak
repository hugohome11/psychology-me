import { NextResponse } from "next/server";
import Stripe from "stripe";
import { PrismaClient } from "@prisma/client";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

const prisma = new PrismaClient();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function POST(req: Request) {
  const sig = req.headers.get("stripe-signature");
  const secret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!sig || !secret) {
    return NextResponse.json({ ok: false, error: "missing headers/secret" }, { status: 400 });
  }

  const raw = await req.text();
  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(raw, sig, secret);
  } catch (err: any) {
    return NextResponse.json({ ok: false, error: `sig verify failed: ${err.message}` }, { status: 400 });
  }

  // Gate 1: dedupe by event.id
  const seen = await prisma.stripeEvent.findUnique({ where: { id: event.id } }).catch(() => null);
  if (seen) return NextResponse.json({ ok: true, deduped: true });
  await prisma.stripeEvent.create({ data: { id: event.id, type: event.type } }).catch(() => null);

  if (event.type === "checkout.session.completed") {
    const s = event.data.object as Stripe.Checkout.Session;
    try {
      const li = await stripe.checkout.sessions.listLineItems(s.id, { limit: 10 });
      const first = li.data[0];

      const priceId = (first?.price as Stripe.Price | null)?.id ?? null;
      const currency = (first?.currency ?? s.currency ?? "").toLowerCase();
      const amountTotalCents =
        (typeof s.amount_total === "number" ? s.amount_total : undefined) ??
        (typeof first?.amount_total === "number" ? first.amount_total : undefined) ??
        0;

      const paymentIntentId =
        typeof s.payment_intent === "string" ? s.payment_intent : s.payment_intent?.id ?? null;
      const email = s.customer_details?.email ?? s.customer_email ?? null;

      // Gate 2: upsert Purchase
      if (email) {
        const existing = await prisma.purchase.findFirst({
          where: { email, priceId },
          select: { id: true },
        });
        if (existing) {
          await prisma.purchase.update({
            where: { id: existing.id },
            data: { lastEventId: event.id, paymentIntentId },
          });
        } else {
          await prisma.purchase.create({
            data: {
              email,
              priceId,
              currency,
              amountTotalCents: Number(amountTotalCents ?? 0),
              sessionId: s.id,
              paymentIntentId,
              lastEventId: event.id,
            },
          });
        }
      } else {
        const maybe = await prisma.purchase.findFirst({
          where: { sessionId: s.id },
          select: { id: true },
        });
        if (maybe) {
          await prisma.purchase.update({
            where: { id: maybe.id },
            data: { lastEventId: event.id, paymentIntentId },
          });
        } else {
          await prisma.purchase.create({
            data: {
              email: "unknown@local",
              priceId,
              currency,
              amountTotalCents: Number(amountTotalCents ?? 0),
              sessionId: s.id,
              paymentIntentId,
              lastEventId: event.id,
            },
          });
        }
      }
    } catch {
      // swallow: event already recorded
    }
  }

  return NextResponse.json({ ok: true });
}