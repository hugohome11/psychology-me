// prisma/schema.prisma

// ---------- Generators & Datasource ----------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // pooled (6543) for runtime
  directUrl = env("DIRECT_URL") // direct (5432) for migrations
}

// ---------- NextAuth v4 (Prisma Adapter) ----------
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?

  accounts    Account[]
  sessions    Session[]
  submissions Submission[]

  // ✨ back-relation for Assessment.author
  assessmentsAuthored Assessment[] @relation("AssessmentAuthor")

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  oauth_token_secret String? @db.Text
  oauth_token        String? @db.Text

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ---------- Stripe / Commerce ----------
model StripeEvent {
  /// Stripe event id (e.g. "evt_...")
  id        String   @id
  type      String?
  createdAt DateTime @default(now())

  @@index([createdAt(sort: Desc)])
}

model Purchase {
  id               String  @id @default(cuid())
  email            String
  priceId          String?
  currency         String  @default("eur")
  amountTotalCents Int     @default(0)
  sessionId        String  @unique
  paymentIntentId  String?
  lastEventId      String

  // optional link to an assessment
  assessmentId String?
  // ✨ name the relation and connect to Assessment.purchases
  assessment   Assessment? @relation("AssessmentPurchases", fields: [assessmentId], references: [id])

  // ✨ back-relation for Submission.purchase (many submissions can reference a purchase)
  submissions Submission[] @relation("PurchaseSubmissions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email, priceId])
  @@index([sessionId])
  @@index([paymentIntentId])
  @@index([lastEventId])
  @@index([assessmentId])
}

// ---------- Assessments Domain ----------
model Assessment {
  id          String  @id @default(cuid())
  slug        String  @unique
  title       String
  description String?
  isPublished Boolean @default(false)

  priceId String?

  authorId String?
  // ✨ name the relation and connect to User.assessmentsAuthored
  author   User?   @relation("AssessmentAuthor", fields: [authorId], references: [id])

  questions   Question[]
  submissions Submission[]

  // ✨ back-relation for Purchase.assessment
  purchases Purchase[] @relation("AssessmentPurchases")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isPublished])
  @@index([priceId])
}

// “Single-choice”, “multi-choice”, “scale/likert”, “free text”, “number” cover most test items.
enum QuestionType {
  SINGLE_CHOICE
  MULTI_CHOICE
  SCALE
  TEXT
  NUMBER
}

model Question {
  id           String       @id @default(cuid())
  assessmentId String
  order        Int // display order within assessment
  type         QuestionType
  prompt       String
  required     Boolean      @default(true)

  // For SCALE you can set min/max/step; for TEXT/NUMBER you can ignore
  minValue Int?
  maxValue Int?
  step     Int?

  assessment Assessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  options    Option[] // for SINGLE/MULTI; empty for SCALE/TEXT/NUMBER
  responses  Response[]

  @@unique([assessmentId, order]) // stable ordering
  @@index([assessmentId])
}

model Option {
  id         String @id @default(cuid())
  questionId String
  order      Int
  label      String
  value      String
  score      Int?

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // ✨ back-relation for Response.option
  responses Response[]

  @@unique([questionId, order])
  @@index([questionId])
}

// A person taking an assessment (logged-in or anonymous)
model Submission {
  id           String    @id @default(cuid())
  assessmentId String
  userId       String?
  email        String?
  startedAt    DateTime  @default(now())
  completedAt  DateTime?

  scoreTotal Int?
  resultJson Json?

  assessment Assessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  user       User?      @relation(fields: [userId], references: [id])
  responses  Response[]

  purchaseId String?
  // ✨ name the relation and connect to Purchase.submissions
  purchase   Purchase? @relation("PurchaseSubmissions", fields: [purchaseId], references: [id])

  @@index([assessmentId])
  @@index([userId])
  @@index([email])
  @@index([purchaseId])
}

model Response {
  id           String  @id @default(cuid())
  submissionId String
  questionId   String
  optionId     String?

  valueNumber Float?
  valueText   String?
  valueJson   Json?
  score       Int?

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  question   Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  option     Option?    @relation(fields: [optionId], references: [id])

  createdAt DateTime @default(now())

  @@unique([submissionId, questionId, optionId])
  @@index([submissionId])
  @@index([questionId])
  @@index([optionId])
}
